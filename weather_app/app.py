import requests
import sys
import csv
from datetime import datetime
from timezonefinder import TimezoneFinder
from zoneinfo import ZoneInfo
from collections import deque
from cleaner import clean #function from cleaner.py 


class Collect_data():

    
    def __init__(self, city, temp, windspeed, date):

        self.city = city
        self.temp = temp
        self.windspeed = windspeed
        self.date = date


    def turn_dict(self):

        return {
            'city': self.city,
            'temperature': self.temp,
            'windspeed': self.windspeed,
            'date-time': self.date
        }


WEEK = [
    'Monday','Tuesday','Wednesday',
    'Thursday','Friday','Saturday',
    'Sunday'
]

MONTHS = {'01': 'Jan', '02': 'Feb', '03': 'Mar', '04': 'Apr',
        '05': 'May','06': 'Jun', '07': 'Jul','08': 'Aug',
        '09': 'Sep','10': 'Oct','11': 'Nov','12': 'Dec'
}



def forecast():
    while True:
        c = input('Enter the city/country name: ').lower()
        api_1 = f'https://geocoding-api.open-meteo.com/v1/search?name={c}'


        try:
            r = requests.get(api_1)
            j = r.json()
            try:
                if not j['results']:
                    sys.exit("City not found. Check the spelling please!")
                for index, i in enumerate(j['results']):#list all the available cities/countries with the given name
                    print(f"{index+1}){i['name']}, {i['country']}")
            except KeyError:
                print('Invalid city/country name!')
                continue
    

            while True:
                try:
                    user = input("Enter the number of the intended city/country: ").lower()
                    if int(user) < 1 or int(user) > len(j['results']):#if the user chooses a number that does not match the index start the loop again
                        print('Input out of range!')
                        continue
                    break
                except ValueError:
                    if user == "quit":
                        sys.exit('You successfully quit the program!')
                    else:
                        print("Invalid input!")
                        continue


            longitude = j['results'][int(user) - 1]['longitude']#if the user chooses a number it subtract one to match everything (1 == 0, 2 == 1 and etc.)
            latitude = j['results'][int(user) -1]['latitude']
            api3 = f"https://api.open-meteo.com/v1/forecast?latitude={latitude}&longitude={longitude}&current_weather=true&hourly=temperature_2m,precipitation_probability&daily=weathercode,temperature_2m_max,temperature_2m_min&timezone=auto"


            r2 = requests.get(api3)
            j2 = r2.json()
            units = j2['daily']
            ind = range(1,8)
            maxt = units['temperature_2m_max']#highest temperature
            mint = units['temperature_2m_min']#lowest temperature


            tf = TimezoneFinder()
            zone = tf.timezone_at(
                lng=longitude,
                lat=latitude
            )

            lst_date = []

            current = datetime.now(ZoneInfo(zone))
            day = current.strftime('%A')#finding the day of the week with a given city/country name

            ind_day = [inde for inde,i in enumerate(WEEK) if i == day][0]
            dates = j2['daily']['time']


            for m in dates:
                month = m[5:7]
                day = m[8:10]
                lst_date.append(day)


            if month in MONTHS.keys():
                month = MONTHS[f'{month}']


            print(f'{'-'*10}\n{'Highest-Lowest'}\n{'-'*10}')

            for z,i,x,y,t in zip(ind,maxt, mint, range(len(WEEK)), lst_date):
                y = (ind_day+y)%7#the remainder is the day of the week in sequence, if it is wednesday the ind_day is 3 and it will be added 0 first and wednesday will be given, then 1 will be added and index 4 and thursday
                if i < 10.0: i = f"0{i}"
                if x < 10.0: x = f"0{x}"

                print(f'{z}){i}°C|{x}°C || {month} {t}th |{WEEK[y]}')


            print(f'{'-'*10}\n{'Highest-Lowest (average)'}\n{'-'*10}')
            avg = f"{round(sum(maxt)/len(maxt), 1)}°C|{round(sum(mint)/len(mint), 1)}°C"

            sys.exit(avg)
        except (requests.exceptions.RequestException):
            sys.exit('Connection error!')

    


                    
def get_country():
    c = " ".join(sys.argv[1:]).lower()
    api_1 = f'https://geocoding-api.open-meteo.com/v1/search?name={c}'
    try:
        r = requests.get(api_1)
        j = r.json()

        if not j['results']:
            sys.exit("City not found. Check the spelling please!")


        for index, i in enumerate(j['results']):
            print(f"{index+1}){i['name']}, {i['country']}")


        while True:
            try:
                user = input("Enter the number of the intended city/country: ").lower()
                if int(user) < 1 or int(user) > len(j['results']):
                    print('Input out of range!')
                    continue
                break
            except ValueError:
                if user == "quit":
                    sys.exit('You successfully quit the program!')
                else:
                    print('Invalid input!')
                    continue


        longitude = j['results'][int(user) - 1]['longitude']
        latitude = j['results'][int(user) -1]['latitude']
        api_2 = f'https://api.open-meteo.com/v1/forecast?latitude={latitude}&longitude={longitude}&current_weather=true'


        r_2 = requests.get(api_2)
        j_2 = r_2.json()


        j2 = j_2['current_weather']
        temp = j2['temperature']
        w_S = j2['windspeed']
        day = j2['is_day']
        date = j2['time']
        
        l = '-'*10
        print(f"{l}\nThe temperature is {temp}°C")
        print(f"The windspeed is {w_S} km/h")

        if day == 1: print(f'Day time\n{l}')
        else: print(f'Night time\n{l}')


        with open('kregg.csv', 'a', newline='') as f:
            columns = ['city', 'temperature', 'windspeed' ,'date-time']
            writer = csv.DictWriter(f, fieldnames=columns)
            form = Collect_data(c, temp, w_S, date)
            writer.writerow(form.turn_dict())


    except requests.exceptions.RequestException:
        print("Check your connection sir!")
    except(KeyError, ValueError):
        print('City/country not found check the spelling!')



def days(directory, num_of_days, c_name):#an average temperature and windspeed calculator in a given number of searches from the user input
    nm = []
    tem = []
    w__s = []

    with open(directory) as f:

        reader = csv.DictReader(f)
        for i in reader:
            if i['city'] == c_name:
                nm.append(i)

        last_lines = deque(nm, maxlen=num_of_days)
        for x in last_lines:
            temp = x['temperature']
            ws = x['windspeed']
            tem.append(float(temp))
            w__s.append(float(ws))


        avgt = sum(tem)/len(tem)
        avgw = sum(w__s)/len(w__s)
        last_days = len(nm)
        if num_of_days > last_days: raise ValueError#if the user input is higher than the available number of searches in csv it will raise a ValueError
        else: pass
        print(f'The average temperature in the last {num_of_days} search(es) is {round(avgt, 1)}°C')
        print(f'The average windspeed in the last {num_of_days} search(es) is {round(avgw, 1)} km/h')




def average():  
        cname = input('Enter the city/country name: ')
        while True:
            try:
                dys = input('Enter the number of days you wanna see the average of: ').lower()
                days('kregg.csv', int(dys), cname)


                sys.exit()
            except ValueError:

                if dys != 'quit':#if the user does not quit nor choose quit or a number this error will be raised
                    print('Invalid input or the given city/country has not been searched this many times!')
                    continue

                else:
                    sys.exit()


def display_saved():#a function to read the csv file without having to go inside of the file 
        with open('kregg.csv') as f:
            for i in f:
                print(i, end='')


command_lst = ['average - to see the average temperature and the windspeed in a certain number of searches',
               'saved - to see the csv file from the terminal',
               'forecast - to see the projected temperature and the windspeed in the upcoming 7 days',
               '<name of country/city> - to see the current temperature of the searched city/country',
               '-h - to list all the functions']


funcs = {
    'average': average,
    'saved': display_saved,
    'forecast': forecast,
    '-h': lambda : [print('*',i) for i in command_lst]
}


def main():
    if len(sys.argv) < 2:
        sys.exit("Not enough arguments on the terminal!\n-h for for help")
    command = funcs.get(sys.argv[1])
    if command:
        command()
    else:
        get_country()


if __name__ == "__main__":
    main()
    clean()